# Term Engine

![](https://img.shields.io/badge/license-MIT-green.svg?style=for-the-badge)

Term Engine - это маленький игровой движок нацеленный
на привычный (в виде использования ООП) и довольно удобный
способ разработки игр на языке C++ с выводом графики в виде
TUI интерфейса.

## Цель

Целью проекта является усовершенствование навыков разработки продуктор
у создателя проекта, а так же у тех, кто его поддерживает.

Второй главной целью является предоставление инструментов для лёгкой
и быстрой разработки маленьких/простых или средних по сложностии видеоигр,
оссобеностью которых является использование TUI для графического вывода.

## Начало

Для использования игрового движка вам нужно
добавить его в cmake вашей игры через _FetchContent_.

```cmake
...

include(FetchContent)
FetchContent_Declare(term_engine
    GIT_REPOSITORY
)
FetchContent_MakeAvailable(term_engine)

...

# Добавление зависимости к вашей игре.
target_include_directories(your_target PRIVATE terminal::engine)
```

Далее нужно создать класс(ы), отвечабщий(ие) за игровую логику.

```c++
#include <term_engine/entity.hp>

// Класс, содержащий логику. В данном случае
// он не будет отображаться в мире.
class YourLogicClass : public tengine::Entity {
    // ВАЖНО! Для работы класс, необходимо обязательно
    // переопределить методы init и update.

    void init() override { /* Логика инициализации. */ }

    void update(double delta_time) override {
        /* Основная логика. Обновляется каждый кадр. */
    }
};

// Класс, который не только содержит логику, но
// который ещё и рисуется в мире.
class YourDrawableLogicClass : public tengine::Entity {
    // Для того, чтобы объект считался отрисооваемым, необходимо
    // в конструктор Entity передать или только глубину (слой, на котором
    // будет происходить отрисовка), или и глубину, и позицию в мире.
    //
    // В данном случае используется 1 вариант.
    YourDrawableLogicClass() : tengine::Entity{30} {}
    //                                        ^- данная сущность будет отрисооваться тридцатой.

    // Функция render по умолчанию возвращает
    // пустое изображение, так что хотя объект
    // и рисуется, его не видно. Поэтому необходимо переопределить
    // данный метод.
    //
    // В этом случае изображение для отрисовки содержит 1 пиксель.
    const tengine::Image render() override {
        tengine::Pixel px;
        px.character = "#";

        return tengine::Image{px};
    }

    // Определение методов init и update.
};
```

Затем после определения ваших классов необходимо создать приложение и добавить
в него классы.

```c++
#include <term_engine/application.hpp>
#include <memory>

int main(void) {
    auto app = tengine::Application::singletion();

    // Приложение принимает только уже созданные сущности динамически.
    auto your_entity = std::make_shared<YourDrawableLogicClass>();
    app->spawn_entity(your_entity);

    // Запуск приложения.
    app->run();
}
```

А также, в 1 момент может быть активно только 1 приложение, так как оно является
синглетоном. Но также из-за этого, в любой момент можно получить приложение внутри
вашей сущности и взаимодействовать с ним (наприме для добавления/удаления другой сущности).


> [!WARNING]
> На данный момент нынешняя реализация игрового движка не является потоко-безопастной. Поэтому не гарантируется отсутствие UB или повреждения данных в многопоточном режиме.

## Лицензия

- [MIT License](LICENSE) или http://opensource.org/licenses/MIT
